3.1
a. Depth first graph search failed even for the easy sudoku puzzle, probably because there are way too many possible solutions for depth first search to even consider in a reasonable amount of time (because it just considers complete solutions).
   AC3 finished the easy puzzle very quickly, but failed to solve the harder and hardest puzzles, this is probably because it uses arc consistency and has too many constraints to handle.
   Backtracking was able to solve the easiest puzzle in a reasonable amount of time, probably because it slowly sets variables and checks if it satisfies constraints, which is easy when the constraints very obviously say what the variable should be. However, it fails to do the harder and hardest problem (in a reasonable amount of time) because the search space grows too large with so many possible values for each variable.
   Min-conflicts was unable to solve even the easiest problem every time, but it should be able to solve it every once in awhile. It fails often because its a local search and may end up "climbing" to an incomplete solution, of which there are many.
b. Setting the select_unassigned variable parameter to mrv caused the backtracking search to fail, oddly. However, setting the parameter inference to forward_checking causes the algorithm to succeed quickly even on the hardest puzzle. So, the best combination of parameters should be mrv and forward checking (because it offers the most optimization). However, even without mrv, forward checking quickly completes the hardest puzzle.

3.2
a. Depth first and AC3 fail even when n=4. However, backtracking search is able to do pretty well until you get above n=20. Min conflicts is able to do fairly well until you get over about n=3000, then it really starts to slow down.
b. By adding mrv and inference to forward checking to backtracking is able to get around n=300 before it really starts to slow down. Those settings work the best because selecting the variable with the minimum number of conflicts and forward checking will greatly reduce your search space.
c. It seems that it's possible to the problem with a low number of max steps if n is small, but as n grows max steps doesn't necessarily scale equally. So, the smaller the problem, the closer and possibly greater the number of steps needs to be in comparison to n. However, as n grows, the number of steps doesn't have to be greater of equal and can actually be much less.

3.3
a. It seems as though search.Problem contains code that is abstract that is meant to be inherited and built upon. It provides the basic structure of a search algorithm because it has initial states, actions, results, goal tests, and costs. Using the class by itself is not possible as it is abstract.
   CSP implements the search.Problem class and maps its variables, domains, and constraints to the traditional states, actions, results, etc. So, states end up being different ways variables are set, actions end up being the possible moves or rather domain, results are the resulting variable assignments after a variable has been set, and the goal test is checking whether all constraints are satisfied.
b. Traditional search algorithms usually look at the 'closeness' to the goal where both the current value and the end value are typically represented numerically, and the costs of moves are represented in how far away you move from the goal. CSPs are a bit different in that they can do something similar but really the heuristics are how many constraints are satisfied by a move and the goal is trying to get to all constraints satisfied.